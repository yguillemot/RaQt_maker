unit module RaQtHelpers;


our constant %qType = {
    "Int" => "int",
    "Str" => "QString",
    "Bool" => "bool"
};

# List of main Qt classes
our constant $qtClasses is export = set
    "RaQt::" <<~<<  <

        #BEGIN_INSERTION_HERE
        #LIST_OF_MAIN_QT_CLASSES

        QtObject QApplication QtLayout QtPaintDevice
                    QtWidget QtTextEdit QtAbstractButton
                    QtPushButton QtBoxLayout QtVBoxLayout
                    QtHBoxLayout QtTimer

        #END_INSERTION_HERE
    >;


our constant $simpleSignatures is export = set <
    ()
    (Int)
    (Int,Int)
    (Str)
    (Str,Str)
    (Int,Str)
    (Str,Int)
    (Bool)
>;


our constant %qSigSig is export = {
    "()" => "()",
    "(Int)" => "(int)",
    "(Int,Int)" => "(int,int)",
    "(Str)" => "(QString)",
    "(Str,Str)" => "(QString,QString)",
    "(Int,Str)" => "(int,QString)",
    "(Str,Int)" => "(QString,int)",
    "(Bool)" => "(bool)"
};


sub libwrapper is export {
  my $lib-name = sprintf($*VM.config<dll>, "RaQtWrapper");
  my $installed-lib = ~(%?RESOURCES{$lib-name});
  return $installed-lib ?? $installed-lib !! "resources/$lib-name";
}


# Die with an error message when ctor not found
sub unimplementedCtor(Str $class) is export is hidden-from-backtrace
{
    # Use Backtrace.new rather than die because die immediately fails with
    # "MoarVM panic: Internal error: Unwound entire stack and missed handler"
    # when called from a callback called from Qt

    note "";
    note "Current RaQt version implements no constructor for class $class.";
    my $trace = Backtrace.new;
    say ~$trace;
    exit;
}


#############################################################################



sub cap2sigStr(Capture $c) is export
{
    my Str $s = "(";
    my Str $sep = "";
    for $c.list -> $e {
        $s ~= $sep ~ $e.WHAT.perl;
        $sep = ",";
    }
    return $s ~ ")";
}


sub sig2str(Signature $s --> Str) is export
{
    my Str $r = "(";
    my Str $sep = "";
    for $s.params -> $p {
        $r ~= $sep ~ $p.type.perl;
        $sep = ",";
    }
    return $r ~ ")";
}

sub sig2qSigStr(Signature $s --> Str) is export
{
    my Str $r = "(";
    my Str $sep = "";
    for $s.params -> $p {
        if %qType{$p.type.perl}:exists {
            $r ~= $sep ~ %qType{$p.type.perl};
        } else {
            $r ~= $sep ~ "UNKNOWN";
        }
        $sep = ",";
    }
    return $r ~ ")";
}


### A METTRE AU POINT !!!!!!!
sub methPosArgs2Str(Signature $s --> Str) is export
{
    # say "METH SIGNAL : ", $meth.name;
    # say "   Signature : ", $meth.signature.params;
    # say "   Middle : ", posArgs2Str($meth.signature.params);
    my Str $r = "(";
    my Str $sep = "";
    my Bool $first = True;
    for $s.params -> $p {
        if $first { $first = False; next }  # Skip the object reference
        last if $p.gist.Str ~~ /\*/;        # Ignore slurpy arguments
        my $t = $p.type.^name;
        $t ~~ s:g/<[\(\)]>**1//;  # Can't use $p.type.raku if type is a stub
        $r ~= $sep ~ $t;
        $sep = ",";
    }
    return $r ~ ")";
}

sub methPosArgs2qSigStr(Signature $s --> Str) is export
{
    # say "METH SIGNAL : ", $meth.name;
    # say "   Signature : ", $meth.signature.params;
    # say "   Middle : ", posArgs2Str($meth.signature.params);
    my Str $r = "(";
    my Str $sep = "";
    my Bool $first = True;
    for $s.params -> $p {
        if $first { $first = False; next }  # Skip the object reference
        last if $p.gist.Str ~~ /\*/;        # Ignore slurpy arguments
        if %qType{$p.type.perl}:exists {
            $r ~= $sep ~ %qType{$p.type.perl};
        } else {
            $r ~= $sep ~ "UNKNOWN";
        }
        $sep = ",";
    }
    return $r ~ ")";
}


# Remove the invocant from a signature
# Return the signature unchanged if no invocant found
sub removeInvocant(Signature $s --> Signature) is export
{
    # Signature should at least have an invocant
    return $s if $s.count ~~ 0;         # Can't be the signature of a method

    # Remove the invocant
    my ($o, @p) = ($s.params);
    return $s unless $o.invocant;        # Is not the signature of a method

    # Create the new signature
    my $newSig = Signature.new(
        arity => $s.arity - 1,
        count => $s.count.Num - 1,
        params => @p,
        returns => $s.returns
    );
    return $newSig;
}



# Simplified signature :Replace the Signature class of Raku
# which currently have some issues making it unusable here

#| Simplified Parameter
class SParameter is export
{
    has Str $.type = "Any";
    has Str $.name = "";;
    has Code $.default;

    # Only for debug
    method dump
    {
        say "    T='", $!type, "' N='", $!name,
                "' D=", $!default ?? &($!default)() !! $!default;
    }

    method str returns Str
    {
        my Str $out = self.type;
        $out ~= " " ~ self.name if self.name;
        $out ~= " = " ~ &(self.default)() if self.default;
        return $out;
    }
}

#| Simplified Signature
class SSignature is export
{
    has Int $.count;
    has Int $.arity;
    has @.params;       # List of SParameter

    #| Return 0 if applying a capture from $s to the SSignature works
    #  Returns -1 if it doesn't work
    #  Return n>0 if n parameters having default values must be removed
    # from the destination signature to allow the Qt connection
    method accepts(SSignature $sig --> Int)
    {
        # Each parameter without default must receive an argument
        return -1 if $sig.count < self.arity;

        # Related parameters must have the same type
        for $sig.params Z self.params -> ($a, $b) {
            return -1 if $a.type !~~ $b.type;
        }

        # Return the number of defaulted parameters without
        # related parameter in $sig
        my $delta = self.count - $sig.count;
        return $delta > 0 ?? $delta !! 0;
    }

    # Only for debug
    method dump
    {
        say "count = ", $!count;
        say "arity = ", $!arity;
        for @!params -> $p {
            $p.dump;
        }
    }

    method str returns Str
    {
        my Str $out = "";
        my Str $sep = "";
        for self.params -> $p {
            $out ~= $sep ~ $p.str;
            $sep ~= ", ";
        }
        return $out;
    }
}


# Create a SSignature object from a list.
#
# Each parameter in the list is described by :
#    - A Str containing the type of the parameter if there is no default value
#    - Or a sublist of three elements :
#          - A Str containing the type of the parameter
#          - A Str containing the name of the parameter (without sigil)
#          - The default value of this parameter
#
# WARNING: To get a valid SSignature with a correct arity:
#   - When a name is provided, a valid default must be provided
#   - The named parameters must be at the end of the parameter list
#     (i.e. an unnamed parameter must never follow a named one)
#
multi sub createSignature(@s --> SSignature) is export
{
    # How many parameters ?
    my Int $count = @s.elems;
    my Int $arity = [+] @s>>.elems <<~~>> 1;

    # Create the list of Parameters
    my @p = ();
    for @s -> $pl {
        if $pl.elems == 3 {

            if $pl[1] !~~ "" {
                @p.push(SParameter.new(
                    type => $pl[0],
                    name => '$' ~ $pl[1],
                    default => createDefault($pl[2])
                ));
            } else {
                @p.push(SParameter.new(
                    type => $pl[0]
                ));
            }

        } else {
            # $pl should be a string and not a list
            @p.push(SParameter.new(type => $pl));
        }
    }

    # Create the signature
    return SSignature.new(
        arity => $arity,
        count => $count,
        params => @p
    );

    # Return a closure returning the default value
    sub createDefault($v) { my $d = $v; return &{ $d } }
}

# Create a SSignature object from a Signature one.
# If the given Signature is coming from a method, its invocant is removed.
multi sub createSignature(Signature $s --> SSignature) is export
{
    my Int $count = $s.count;
    my Int $arity = $s.arity;
    my @p = $s.params;
    my @q = ();

    # create a liste of SParameter from the list of Parameter
    for @p -> $p {

        if $p.invocant {
            # Remove the invocant if any
            $count--;
            $arity--;
            next;
        }

        if $p.slurpy {
            # Ignore last parameter "*%_" of methods
            next;
        }

        @q.push(SParameter.new(
            type => $p.type.raku,
            name => ($p.name && $p.default) ?? $p.name !! '',
            default => $p.default
        ));
    }

    # Create the new SSignature
    my $ss = SSignature.new(
        arity => $arity,
        count => $count,
        params => @q
    );
    return $ss;
}



# Remove $n args from the stringified Raku signature $sig
sub removeArgs(Str $sig is copy, Int $n --> Str) is export
{
    my $p = $sig.chars;
    for (1..$n) {
    say "'", $sig, "' : ", $p, " ", $p.WHAT;;
        $p = rindex $sig, ',', $p - 1;
    say "'", $sig, "' : ", $p, " ", $p.WHAT;;
        return '()' if !$p;
    }
    $sig.substr-rw($p) = ')';
    return $sig;
}
